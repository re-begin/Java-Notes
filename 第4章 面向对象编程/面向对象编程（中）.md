# 面向对象编程（中）

## OOP特征二：继承性
一、继承性的好处  
1. 减少了代码的冗余，提高了代码的复用性  
2. 便于功能的扩展  
3. 为之后的多态性的使用提供了前提  

二、 继承性的格式：`class A extends B{ }`  
A：子类、派生类、subclass  
B：父类、超类、基类、superclass  
1. 一旦子类A继承父类B之后，子类A就获取了父类B中所有的结构：属性、方法  
特别的，父类中声明为private的属性或方法，子类继承父类时也被继承了，只是因为封装性的影响，使得子类不能直接调用父类的结构而已  
2. 子类继承父类以后，还可以声明子类特有的属性和方法，实现功能的扩展  
子类和父类的关系，不同于子集和集合的关系（子类非子集，子类功能更多）  

```java
public class Student extends Person{
}
```

三、Java中关于继承性的规定  
1. 一个类可以被多个子类继承  
2. Java中类的单继承性：一个类只能有一个父类（C++可以多继承）  
3. Java支持多层继承：A继承B，B继承C（B是A的直接父类，C是A的间接父类）  
4. 子类继承父类之后，就获取了直接父类以及所有间接父类中声明的属性和方法  

四、Object类
1. 如果我们没有显式的声明一个类的父类，则此类继承于java.lang.Object类  
2. 所有的java类（除java.lang.Object）都直接或间接的继承于java.lang.Object类  
3. 意味着，所有的java类都具有java.lang.Object类声明的功能

## 方法的重写override
1. 重写：子类继承父类之后，可以对父类中同名同参的方法进行覆盖  
2. 应用：重写之后，当创建子类对象后，通过子类对象调用子父类中的同名同参的方法时，实际执行的是子类重写父类的方法  
3. 重写的规定：  
    方法的声明：权限修饰符 返回值类型 方法名(形参列表) throws 异常的类型{  
        // 方法体  
    }
    - 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同  
    - 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符  
    特殊情况：子类不能重写父类中声明为private权限的方法  
    - 返回值类型：  
        - 如果父类被重写的方法的返回值类型是void，则子类重写的方法的返回值只能是void  
        - 如果父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类  
        - 如果父类被重写的方法的返回值类型是基本数据类型（比如：double），则子类重写的方法的返回值类型必须是相同的基本数据类型（必须也是double）
    - 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（详见异常处理）  
4. 子类和父类中的同名同参的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写）

```java
public class Person {
	
	String name;
	int age;
	
	public Person(){

	}
	public Person(String name,int age){
		this.name = name;
		this.age = age;
	}
	
    // 缺省的，可被重写为public的
	void eat(){
		System.out.println("吃饭");
	}

	public void walk(int distance){
		System.out.println("走路,走的距离是：" + distance + "公里");
		show(); // Student类的实例化调用walk方法后，此时show是Person类的，因为private show()不构成重写
		eat(); // Student类的实例化调用walk方法后，此时eat是Student类的，因为缺省的show()构成重写
	}
	
    // private的，不构成重写
	private void show(){
		System.out.println("我是一个人");
	}
	
	public Object info(){
		return null;
	}
	
	public double info1(){
		return 1.0;
	}

}


public class Student extends Person{

	String major;
	
	public Student(){
		
	}
	public Student(String major){
		this.major = major;
	}
	
	public void study(){
		System.out.println("学习。专业是：" + major);
	}
	
	// 对父类中的eat()进行了重写，父类的eat方法权限修饰符为缺省的
	public void eat(){
		System.out.println("学生应该多吃有营养的食物");
	}

    // 正确的方法的重写
    // @Override
    // public void walk(int distance) {
	// 	System.out.println("重写的方法");
	// }

	// 父类中show方法是private的，此时不构成重写
	public void show(){
		System.out.println("我是一个学生");
	}

	// 
	public String info(){
		return null;
	}
	
    // 报错：The return type is incompatible with Person.info1()
    // 父类info1方法的返回值是double，不能在子类中返回int
	// public int info1(){
	// 	return 1;
	// }
}


public class PersonTest {
	public static void main(String[] args) {
		
		Student s = new Student("计算机科学与技术");
		s.eat(); // 学生应该多吃有营养的食物
		s.walk(10); // 走路,走的距离是：10公里
                    // 我是一个人 （Person类中的show方法）
                    // 学生应该多吃有营养的食物（Student类中的eat方法）
		s.study(); // 学习。专业是：计算机科学与技术
	}
}
```

面试题：区分方法的重载与重写  
重载：在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数或者类型不同即可。跟方法的返回值类型、形参变量名、访问修饰符、方法体无关  
重写：子类继承父类以后，可以对父类同名同参数的方法，进行覆盖操作  

## 四种访问权限修饰符
|  修饰符   | 类内部  | 同一个包 | 不同包的子类 | 同一个工程 |
| :----:   | :----: | :----:  | :----:     | :----:   |
| private  | Yes    |         |            |          |
| 缺省      | Yes    | Yes     |            |          |
| protected  | Yes  | Yes    |  Yes       |          |
| public  | Yes    | Yes     |  Yes       | Yes      |

不同包的子类：A在AA包中，B在BB包中，但是B extends A，B可以调用A中声明的protected和public的属性、方法

## 关键字：super

## 子类对象实例化过程

## OOP特征三：多态性

## Object类的使用

## 包装类的使用