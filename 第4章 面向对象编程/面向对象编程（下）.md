# 面向对象编程（下）

## 关键字：static
static关键字的使用  
1. static：静态的
2. static可以用来修饰：属性、方法、代码块、内部类（不能修饰构造器）
3. 使用static修饰属性：静态变量（或类变量）  
    - 属性，按是否使用static修饰分为：静态属性 vs 非静态属性（实例变量）  
        - 实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性，不会导致其他对象中的同样的属性值的修改  
        - 静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改后的  
    
    - static修饰属性的其他说明：
        - 静态变量随着类的加载而加载，可以通过`类.静态变量`的方式调用（实例变量随着对象的创建而加载）  
        - 静态变量的加载早于对象的创建  
        - 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中  
        - 
            |        |  类变量  | 实例变量 |  
            | :----: | :----:  | :----: |
            | 类     |  yes    | no      |  
            | 对象    |  yes    | yes    |  
           
    - 静态属性举例：System.out、 Math.PI
4. 使用static修饰方法：静态方法  
    - 随着类的加载而加载，可以通过`类.静态方法`的方式进行调用 
    -  
        |        |  静态方法  | 非静态方法 |  
        | :----: | :----:  | :----: |
        | 类     |  yes    | no      |  
        | 对象    |  yes    | yes    |  
    - 静态的方法中，只能调用静态的方法或静态的属性；非静态方法中，既可以调用非静态的方法和属性，也可以调用静态的方法和属性
5. static注意点：  
在静态方法中不能使用this和super关键字 
6. 在开发中，如何确定一个属性是否要声明为static的？  
    属性是可以被多个对象所共享的，不会随着对象的不同而不同的  
    类中的常量也常常声明为static的      
7. 在开发中，如何确定一个方法是否要声明为static的？  
    操作静态属性的方法，通常设置为static的  
    工具类中的方法，习惯上声明为static的，比如：Math、Array、Collections

```java
public class StaticTest {
    public static void main(String[] args) {
        Chinese c1 = new Chinese();
        c1.name = "张三";
        c1.age = 40; 
        c1.nation = "CHN";
        
        Chinese c2 = new Chinese();
        c2.name = "李四";
        c2.age = 30;
        c2.nation = "CHINA";

        System.out.println(c1.nation); // "CHINA"
    }
}

class Chinese {
    String name;
    int age;

    static String nation;

    public void eat() {
        System.out.println("中国人吃中餐");
        // 调用非静态结构
        this.info();
        // 调用静态结构
        walk();
        System.out.println("nathin: " + nation);
    }

    public static void show(){
        System.out.println("我是中国人");
        // 不能调用非静态的结构
        // eat();
        // name = "Tom"
        // 可以调用静态的结构
        System.out.println(Chinese.nation); // Chinese.nation可以简写为nation
        walk();
    }

    public void info() {
        System.out.println("name: " + name + ", age: " + age);
    }

    public static void walk() {
        System.out.println("人走路");
    }
}
```

## 单例设计模式（补充）
> 设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方法  
> 设计模式免去了我们自己再思考和摸索  
> 式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，是一种“套路化”的东西

单例设计模式  
1. 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件体系中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法  
优点：只生产一个实例，减少了系统性能开销  
举例：java.lang.Runtime  

2. 如何实现？  
    饿汉式 and 懒汉式  
    饿汉式直接new，懒汉式用的时候（调静态方法时）再new  
3. 区分饿汉式和懒汉式  
    饿汉式  
    - 坏处：对象加载时间过长  
    - 好处：饿汉式是线程安全的  

    懒汉式
    - 好处：延迟对象的创建  
    - 目前的写法坏处：线程不安全 --> 到多线程内容时，再修改

```java
public class SingletonTest {
    public static void main(String[] args) {
        // Bank bank1 = new Bank(); 构造器私有化后，无法通过此方法造对象
        Bank bank1 = Bank.getInstance();
        Bank bank2 = Bank.getInstance();
        System.out.println(bank1 == bank2); // true

        Order order1 = Order.getInstance();
        Order order2 = Order.getInstance();
        System.out.println(order1 == order2); // true

    }
}

// 饿汉式
class Bank {
    // 1. 私有化类的构造器
    private Bank() { }
    
    // 2. 内部创建类的对象
    // 4. 要求此对象也必须声明为静态的
    private static Bank instance = new Bank();

    // 3. 提供公共的静态方法，返回类的对象
    public static Bank getInstance() {
        return instance;
    }
}

// 懒汉式
class Order {
    // 1. 私有化类的构造器
    private Order() { }
    
    // 2. 声明当前类对象，没有初始化
    // 4. 要求此对象也必须声明为静态的
    private static Order instance = null;

    // 3. 声明public、static的返回当前类对象的方法
    public static Order getInstance() {
        if (instance == null) {
            instance = new Order();
        }
        return instance;
    }
}
```

## 理解main方法的语法

## 类的成员之四：代码块

## 关键字：final

## 抽象类与抽象方法

## 接口（interface）

## 类的成员之五：内部类  